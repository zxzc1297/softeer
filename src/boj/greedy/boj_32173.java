package boj.greedy;
import java.util.*;

/**
 * 문제
 * 오늘 참슬기식당의 점심 메뉴는 치킨마요덮밥이다. 그래서 그런지 평소보다 훨씬 많은 학생들이 줄을 선다. 학생들은
 * $1$번부터
 * $N$번까지 번호표를 가지고 있다. 학생들은 번호표에 따라 순서대로 줄을 서려고 한다.
 * $1$번 번호표를 가진 학생은 줄에 처음으로 서게 되고, 이때 만족도는
 * $s_1$이다.
 * $2$번 번호표를 가진 학생부터는 다음 두 가지 행동 중 하나를 선택해 줄을 선다.
 *
 * 맨 앞에 서기: 줄의 맨 앞에 서게 되고, 이때
 * $i$번 학생의 만족도는
 * $s_i$이다.
 * 맨 뒤에 서기: 줄의 맨 뒤에 서게 되고, 이때
 * $i$번 학생의 만족도는
 * $0$이다.
 * 또한 줄을 서는 방법에 따라 기존 학생의 만족도가 변화할 수 있다.
 *
 * 만약
 * $i$번 학생 앞에
 * $j$
 * $(j > i)$번 학생이 있다면 새치기를 당했기 때문에
 * $i$번 학생의 만족도가
 * $−s_i$로 변한다.
 * 기존 만족도가
 * $0$이었더라도
 * $-s_i$로 변할 수 있음에 유의하라.
 * 만약
 * $i$번 학생 앞에
 * $j$
 * $(j > i)$번 학생이 없다면 새치기를 당하지 않았기 때문에
 * $i$번 학생의 만족도는 변하지 않는다.
 * 식당 도우미인 여러분은 문득 각 학생의 만족도 총합을 최대화하는 방법이 궁금해졌다. 만족도 총합의 최댓값을 구해보자.
 *
 * 입력
 * 첫 번째 줄에 학생의 수
 * $N$이 주어진다.
 *
 * 두 번째 줄에 양의 정수
 * $s_1$,
 * $s_2$,
 * $s_3$,
 * $\cdots$,
 * $s_N$이 공백으로 구분되어 주어진다.
 *
 * 출력
 * 첫 번째 줄에 만족도 총합의 최댓값을 출력한다.
 *
 * 제한
 *
 * $1 \le N \le 100\,000$ 
 *
 * $1 \le s_i \le 10^9$ 
 *
 * $1 \le i \le N$ 
 * 예제 입력 1
 * 2
 * 1 10
 * 예제 출력 1
 * 9
 * 예제 입력 2
 * 3
 * 10 1 1
 * 예제 출력 2
 * 10
 * 예제 입력 3
 * 4
 * 1 2 4 1
 * 예제 출력 3
 * 1
 */
public class boj_32173 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // 학생의 수 N 입력
        int n = sc.nextInt();

        // dp[i-1] 역할을 할 변수 (현재까지의 최대 만족도)
        long maxSatisfaction = 0;
        // 누적 합 (s_1 + ... + s_{i-1})을 저장할 변수
        long prefixSum = 0;

        // 1번 학생부터 N번 학생까지 순차적으로 처리
        for (int i = 1; i <= n; i++) {
            // i번째 학생의 만족도 s_i 입력
            long s_i = sc.nextLong();

            if (i == 1) {
                // 1번 학생은 무조건 맨 앞에 서므로 만족도는 s_1
                maxSatisfaction = s_i;
            } else {
                // 2번 학생부터는 두 가지 선택 가능
                // 선택 1: 맨 뒤에 서기 (기존 최대 만족도 유지)
                long choiceBack = maxSatisfaction;

                // 선택 2: 맨 앞에 서기 (s_i - 이전까지의 누적합)
                long choiceFront = s_i - prefixSum;

                // 두 선택 중 더 큰 값으로 최대 만족도 갱신
                maxSatisfaction = Math.max(choiceBack, choiceFront);
            }

            // 다음 계산을 위해 현재 s_i를 누적 합에 더함
            prefixSum += s_i;
        }

        // 최종 결과 출력
        System.out.println(maxSatisfaction);

        sc.close();
    }
}
